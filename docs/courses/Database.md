# Week 1

relation sheet
relationship
relation: set of sets

# Week 2 Entity

| ç±»åˆ«     | æœ¯è¯­                                             | å®šä¹‰                                         |
| -------- | ------------------------------------------------ | -------------------------------------------- |
| **å®ä½“** | å¼ºå®ä½“ (strong entity)                           | ç‹¬ç«‹å­˜åœ¨ã€æœ‰è‡ªèº«ä¸»é”®çš„å®ä½“                   |
|          | å¼±å®ä½“ (weak entity)                             | ä¾èµ–å¼ºå®ä½“ä¸»é”®æ‰èƒ½å”¯ä¸€æ ‡è¯†çš„å®ä½“             |
|          | æ­£åˆ™å®ä½“ (regular entity)                        | ä¸å¼ºå®ä½“åŒä¹‰ï¼Œå¼ºè°ƒç‹¬ç«‹å­˜åœ¨                   |
|          | å­˜åœ¨ä¾èµ– (existence-dependent)                   | å®ä½“å­˜åœ¨ä¾èµ–äºå¦ä¸€ä¸ªå®ä½“                     |
|          | å­˜åœ¨ç‹¬ç«‹ (existence-independent)                 | å®ä½“å¯ç‹¬ç«‹å­˜åœ¨ï¼Œä¸ä¾èµ–å…¶ä»–å®ä½“               |
| **å±æ€§** | ç®€å•å±æ€§ (simple attribute)                      | åŸå­ä¸å¯å†åˆ†ï¼Œå¦‚â€œæ€§åˆ«â€                       |
|          | æ´¾ç”Ÿå±æ€§ (derived attribute)                     | å¯ç”±å…¶å®ƒå±æ€§è®¡ç®—ï¼Œå¦‚â€œå¹´é¾„â€                   |
|          | å¤åˆå±æ€§ (composite attribute)                   | ç”±å¤šä¸ªå­å±æ€§ç»„æˆï¼Œå¦‚â€œåœ°å€â€ï¼ã€ˆçœã€å¸‚ã€è¡—é“ã€‰ |
|          | å¤šå€¼å±æ€§ (multivalued attribute)                 | åŒä¸€å®ä½“å¯æœ‰å¤šä¸ªå€¼ï¼Œå¦‚â€œç”µè¯å·ç â€             |
|          | å•å€¼å±æ€§ (single-valued attribute)               | æ¯ä¸ªå®ä½“å®ä¾‹ä»…ä¸€ä¸ªå€¼ï¼Œå¦‚â€œèº«ä»½è¯å·â€           |
|          | å¿…éœ€å±æ€§ (required attribute)                    | ä¸å¯ä¸ºç©ºçš„å±æ€§                               |
|          | å¯é€‰å±æ€§ (optional attribute)                    | å¯å–ç©ºå€¼çš„å±æ€§                               |
|          | åŸŸ (domain)                                      | å±æ€§å–å€¼èŒƒå›´ï¼Œå¦‚æ€§åˆ«åŸŸ={ç”·, å¥³}              |
| **å…³ç³»** | äºŒå…ƒå…³ç³» (binary relationship)                   | ä¸¤ä¸ªå®ä½“é—´å…³è”ï¼Œå¦‚â€œå‘˜å·¥-æ‰€å±-éƒ¨é—¨â€           |
|          | ä¸‰å…ƒå…³ç³» (ternary relationship)                  | ä¸‰ä¸ªå®ä½“åŒæ—¶å‚ä¸çš„å…³è”                       |
|          | ä¸€å…ƒå…³ç³»/é€’å½’å…³ç³» (unary/recursive relationship) | åŒä¸€å®ä½“çš„è‡ªå¼•ç”¨å…³ç³»                         |
|          | å¼ºï¼ˆæ ‡è¯†ï¼‰å…³ç³» (identifying)                     | ç”¨äºæ ‡è¯†å¼±å®ä½“ä¸»é”®çš„å…³ç³»                     |
|          | å¼±ï¼ˆéæ ‡è¯†ï¼‰å…³ç³» (non-identifying)               | æ™®é€šä¸»å¤–é”®å…³ç³»ï¼Œä¸å‚ä¸å¼±å®ä½“æ ‡è¯†             |
|          | è¿é€šæ€§/åŸºæ•° (connectivity/cardinality)           | æè¿°å…³è”çš„ 1:1ã€1:Nã€M:N ç±»å‹                |
|          | å‚ä¸åº¦ (participation)                           | å®ä½“åœ¨å…³ç³»ä¸­æ˜¯å¦å¿…éœ€ï¼šå¼ºåˆ¶/å¯é€‰              |
| **å»ºæ¨¡** | æ ‡è¯†ç¬¦ (identifiers)                             | å®ä½“ä¸»é”®ï¼Œåˆ†ç®€å•æ ‡è¯†ç¬¦ã€å¤åˆæ ‡è¯†ç¬¦           |
|          | å…³ç³»æ¨¡å¼ (relational schema)                     | ER æ¨¡å‹æ˜ å°„åˆ°å…³ç³»æ¨¡å‹åçš„è¡¨ç»“æ„å®šä¹‰          |
|          | è¿­ä»£è¿‡ç¨‹ (iterative process)                     | ER å»ºæ¨¡çš„åå¤å®Œå–„æµç¨‹                        |

# Week 6 Considering Personal Data in Database Design | Creating & Altering the Database

## Considering Personal Data in Database Design

## Creating & Altering the Database

### Components of SQL language

- DDL(Data Definition Language)
- DML(Data Manipulation Language)
- DCL(Data Conrtol Language)

### Oracle Data Type

### DDL

#### Common ORACLE Data Types
| Code | Data Type                                                      | å‚æ•°ä¿¡æ¯è¯´æ˜                                                |
| ---- | -------------------------------------------------------------- | ----------------------------------------------------------- |
| 1    | VARCHAR2(size [BYTEï½œCHAR])                                    | `size`ï¼šæœ€å¤§é•¿åº¦ï¼›BYTE/CHARï¼šæŒ‰å­—èŠ‚æˆ–å­—ç¬¦è®¡æ•°               |
| 1    | NVARCHAR2(size)                                                | `size`ï¼šæœ€å¤§å­—ç¬¦æ•°ï¼ˆä»¥å­—ç¬¦ä¸ºå•ä½ï¼Œæ”¯æŒUnicodeï¼‰             |
| 2    | NUMBER([precision [, scale]])                                  | `precision`ï¼šæ€»ä½æ•°ï¼›`scale`ï¼šå°æ•°ä½æ•°                      |
| 8    | LONG                                                           | æœ€å¤šå­˜å‚¨ 2GB å­—ç¬¦æ•°æ®ï¼ˆå·²è¿‡æ—¶ï¼Œä¸æ¨èä½¿ç”¨ï¼‰                 |
| 12   | DATE                                                           | å­˜å‚¨æ—¥æœŸå’Œæ—¶é—´ï¼ˆç²¾ç¡®åˆ°ç§’ï¼‰ï¼ŒåŸºäº **Gregorian** å†æ³•         |
| 21   | BINARY_FLOAT                                                   | å•ç²¾åº¦æµ®ç‚¹æ•°ï¼ˆ32ä½ï¼‰                                        |
| 22   | BINARY_DOUBLE                                                  | åŒç²¾åº¦æµ®ç‚¹æ•°ï¼ˆ64ä½ï¼‰                                        |
| 23   | RAW(size)                                                      | `size`ï¼šæœ€å¤§å­—èŠ‚æ•°ï¼ˆå­˜å‚¨äºŒè¿›åˆ¶æ•°æ®ï¼‰                        |
| 24   | LONG RAW                                                       | æœ€å¤šå­˜å‚¨ 2GB äºŒè¿›åˆ¶æ•°æ®ï¼ˆå·²è¿‡æ—¶ï¼Œä¸æ¨èä½¿ç”¨ï¼‰               |
| 69   | ROWID                                                          | å­˜å‚¨è¡Œçš„å”¯ä¸€ç‰©ç†åœ°å€                                        |
| 96   | CHAR [(size [BYTEï½œCHAR])]                                     | `size`ï¼šå›ºå®šé•¿åº¦å­—ç¬¦ä¸²ï¼›BYTE/CHARï¼šæŒ‰å­—èŠ‚æˆ–å­—ç¬¦è®¡æ•°         |
| 96   | NCHAR[(size)]                                                  | `size`ï¼šå›ºå®šé•¿åº¦ Unicode å­—ç¬¦ä¸²                             |
| 112  | CLOB                                                           | å­˜å‚¨å¤§å¯¹è±¡ï¼Œæœ€å¤§ 4GB å­—ç¬¦æ•°æ®                               |
| 112  | NCLOB                                                          | å­˜å‚¨å¤§å¯¹è±¡ï¼Œæœ€å¤§ 4GB Unicode å­—ç¬¦æ•°æ®                       |
| 113  | BLOB                                                           | å­˜å‚¨äºŒè¿›åˆ¶å¤§å¯¹è±¡ï¼Œæœ€å¤§ 4GB                                  |
| 114  | BFILE                                                          | å­˜å‚¨å¤–éƒ¨æ–‡ä»¶çš„äºŒè¿›åˆ¶æ•°æ®ï¼ˆåªè¯»ï¼Œæ•°æ®åº“å¤–éƒ¨ï¼‰                |
| 180  | TIMESTAMP [(fractional_seconds)]                               | `fractional_seconds`ï¼šå°æ•°ç§’ä½æ•°ï¼ˆ0â€“9ï¼‰                     |
| 181  | TIMESTAMP [(fractional_seconds)] WITH TIME ZONE                | å¸¦æ—¶åŒºçš„æ—¶é—´æˆ³                                              |
| 182  | INTERVAL YEAR [(year_precision)] TO MONTH                      | `year_precision`ï¼šå¹´ä½æ•°ï¼ˆé»˜è®¤2ï¼Œæœ€å¤§9ï¼‰                    |
| 183  | INTERVAL DAY [(day_precision)] TO SECOND[(fractional_seconds)] | `day_precision`ï¼šå¤©ä½æ•°ï¼›`fractional_seconds`ï¼šç§’çš„å°æ•°ä½æ•° |
| 208  | UROWID [(size)]                                                | `size`ï¼šæœ€å¤§å­˜å‚¨é•¿åº¦ï¼Œç”¨äºå­˜å‚¨ç´¢å¼•ç»„ç»‡è¡¨è¡Œåœ°å€              |
| 231  | TIMESTAMP [(fractional_seconds)] WITH LOCAL TIMEZONE           | å¸¦æœ¬åœ°æ—¶åŒºçš„æ—¶é—´æˆ³                                          |

#### Create Syntax
```sql
CREATE TABLE table_name (
  column_name data_type [DEFAULT expr] [constraint],
  ...
  [table_constraints]
);

```

#### Column VS Table Level Constraints
| çº¦æŸç±»å‹        | åˆ—çº§å¯å®šä¹‰ | è¡¨çº§å¯å®šä¹‰ | è¯´æ˜                                                 |
| --------------- | ---------- | ---------- | ---------------------------------------------------- |
| **NOT NULL**    | âœ…          | âŒ          | **åªèƒ½åˆ—çº§**ï¼Œå› ä¸ºå®ƒåªé’ˆå¯¹å•ä¸€åˆ—ã€‚                   |
| **PRIMARY KEY** | âœ…          | âœ…          | è¡¨çº§å¯ä»¥å®šä¹‰ **å¤åˆä¸»é”®**ï¼ˆå¤šåˆ—ï¼‰ï¼Œåˆ—çº§åªèƒ½å•åˆ—ã€‚    |
| **UNIQUE**      | âœ…          | âœ…          | è¡¨çº§å¯ä»¥å®šä¹‰ **å¤šåˆ—å”¯ä¸€æ€§**ï¼Œåˆ—çº§åªèƒ½å•åˆ—å”¯ä¸€ã€‚      |
| **FOREIGN KEY** | âœ…          | âœ…          | åˆ—çº§ï¼šå•åˆ—å¤–é”®ï¼›è¡¨çº§ï¼šå¯ä»¥å®šä¹‰å¤åˆå¤–é”®ï¼ˆæ¶‰åŠå¤šåˆ—ï¼‰ã€‚ |
| **CHECK**       | âœ…          | âœ…          | è¡¨çº§ï¼šå¯ä»¥è·¨å¤šåˆ—æ£€æŸ¥ï¼›åˆ—çº§ï¼šä»…é’ˆå¯¹è¯¥åˆ—ã€‚             |

**All constraints other than the not null constraints must have a name.**

#### Alter Syntax

- use alter add constraint
    ```sql
    -- 1) ä¸»é”®ï¼ˆå¯å¤šåˆ—ï¼‰
    ALTER TABLE emp
    ADD CONSTRAINT pk_emp PRIMARY KEY (emp_id)
    USING INDEX;              -- å¯é€‰ï¼šç´¢å¼•é€‰é¡¹/è¡¨ç©ºé—´ç­‰

    -- 2) å”¯ä¸€çº¦æŸï¼ˆå¯å¤šåˆ—ï¼‰
    ALTER TABLE emp
    ADD CONSTRAINT uq_emp_name UNIQUE (emp_name);

    -- 3) å¤–é”®ï¼ˆæ”¯æŒçº§è”/å¯å»¶è¿Ÿæ£€æŸ¥ï¼‰
    ALTER TABLE emp
    ADD CONSTRAINT fk_emp_dept
    FOREIGN KEY (dept_no)
    REFERENCES department(dept_no)
    ON DELETE SET NULL        -- æˆ– ON DELETE CASCADE
    DEFERRABLE INITIALLY DEFERRED;  -- å¯é€‰ï¼šäº‹åŠ¡æäº¤æ—¶å†æ£€æŸ¥

    -- 4) æ£€æŸ¥çº¦æŸï¼ˆå¯è·¨åˆ—ï¼‰
    ALTER TABLE emp
    ADD CONSTRAINT ck_salary CHECK (salary > 0);

    -- 5) NOT NULLï¼ˆåªèƒ½èµ° MODIFY è¯­æ³•ï¼Œè§ä¸‹èŠ‚ï¼‰

    -- çº¦æŸçŠ¶æ€ç®¡ç†
    -- å¯ç”¨/ç¦ç”¨
    ALTER TABLE emp ENABLE  CONSTRAINT fk_emp_dept;
    ALTER TABLE emp DISABLE CONSTRAINT fk_emp_dept;

    -- æ˜¯å¦ç«‹å³æ ¡éªŒå†å²æ•°æ®
    ALTER TABLE emp ENABLE  VALIDATE   CONSTRAINT fk_emp_dept;  -- ç«‹å³æ£€æŸ¥ç°æœ‰æ•°æ®
    ALTER TABLE emp ENABLE  NOVALIDATE CONSTRAINT fk_emp_dept;  -- ä»…å¯¹æ–°æ•°æ®ç”Ÿæ•ˆ
    ```
- use alter modify attributes
    ```sql
    -- 1) æ”¹æ•°æ®ç±»å‹/é•¿åº¦/ç²¾åº¦
    ALTER TABLE emp MODIFY (emp_name VARCHAR2(200 CHAR));
    ALTER TABLE emp MODIFY (salary   NUMBER(10,2));

    -- 2) è®¾ç½®/ç§»é™¤é»˜è®¤å€¼
    ALTER TABLE emp MODIFY (salary DEFAULT 0);
    ALTER TABLE emp MODIFY (salary DEFAULT NULL);

    -- 3) è®¾ç½® NOT NULLï¼ˆå¯å‘½åçº¦æŸï¼‰
    ALTER TABLE emp MODIFY (emp_name CONSTRAINT nn_emp_name NOT NULL);

    -- 4) å…è®¸ NULL
    ALTER TABLE emp MODIFY (emp_name NULL);
    ```
- use alter for mulitple change
    ```sql
    ALTER TABLE employees
      ADD CONSTRAINT pk_emp PRIMARY KEY (emp_id)
      ADD CONSTRAINT ck_salary CHECK (salary > 0)
      MODIFY (emp_name VARCHAR2(100) NOT NULL)
      MODIFY (salary DEFAULT 0);
    ```

---

Oracle ALTER å¯¹å·²æœ‰æ•°æ®çš„å½±å“

åœ¨ **Oracle** é‡Œï¼Œ`ALTER TABLE` ä¿®æ”¹åˆ—å®šä¹‰æˆ–å¢åŠ çº¦æŸæ—¶ï¼Œæ˜¯å¦ç«‹å³ä½œç”¨äºå·²æœ‰æ•°æ®ï¼Œå–å†³äºæ“ä½œç±»å‹ï¼š


1. `MODIFY` ä¿®æ”¹åˆ—å®šä¹‰

* **åŠ é•¿åˆ—é•¿åº¦**

  * ç«‹å³ç”Ÿæ•ˆï¼Œä¸å½±å“å·²æœ‰æ•°æ®ã€‚

  ```sql
  ALTER TABLE emp MODIFY (ename VARCHAR2(200));
  ```

* **ç¼©çŸ­åˆ—é•¿åº¦ / æ”¹ç²¾åº¦**

  * Oracle ä¼šç«‹åˆ»æ£€æŸ¥å·²æœ‰æ•°æ®æ˜¯å¦èƒ½å®¹çº³ã€‚
  * å¦‚æœæœ‰æ•°æ®è¶…å‡ºèŒƒå›´ â†’ æŠ¥é”™ï¼ŒDDL ä¸ä¼šæˆåŠŸã€‚
  * éœ€è¦æ‰‹åŠ¨æ¸…ç†/è½¬æ¢æ•°æ®åå†æ‰§è¡Œã€‚

* **DEFAULT å€¼**

  * å¯¹å·²æœ‰è¡Œ **ä¸æ”¹å˜**ï¼Œåªå¯¹ **ä¹‹åæ’å…¥/æ›´æ–°æ—¶ç¼ºçœå€¼** ç”Ÿæ•ˆã€‚

* **NOT NULL**

  * Oracle ä¼šç«‹åˆ»æ£€æŸ¥å·²æœ‰æ•°æ®æ˜¯å¦å­˜åœ¨ `NULL`ï¼Œå¦‚æœæœ‰ â†’ æŠ¥é”™ã€‚

---

2. `ADD CONSTRAINT`

* **PRIMARY KEY / UNIQUE / CHECK**

  * é»˜è®¤ `ENABLE VALIDATE` â†’ Oracle ä¼šç«‹åˆ»æ£€æŸ¥å…¨è¡¨æ•°æ®æ˜¯å¦ç¬¦åˆã€‚
  * å¦‚æœæ•°æ®ä¸ç¬¦åˆ â†’ æŠ¥é”™ï¼ŒDDL å¤±è´¥ã€‚
  * å¯ä»¥ç”¨ `ENABLE NOVALIDATE` è·³è¿‡å·²æœ‰æ•°æ®æ£€æŸ¥ï¼Œä»…å¯¹æ–°æ•°æ®ç”Ÿæ•ˆã€‚

  ```sql
  ALTER TABLE emp ADD CONSTRAINT ck_salary CHECK (salary > 0) ENABLE NOVALIDATE;
  ```

* **FOREIGN KEY**

  * é»˜è®¤åŒæ ·ä¼šæ£€æŸ¥å·²æœ‰æ•°æ®ï¼›
  * å¯ç”¨ `ENABLE NOVALIDATE` è·³è¿‡æ£€æŸ¥ï¼Œä»…å¯¹æ–°æ•°æ®ç”Ÿæ•ˆã€‚

---

- æ€»ç»“

* **å¤§éƒ¨åˆ† ALTER** â†’ é»˜è®¤ç«‹å³ä½œç”¨å¹¶æ ¡éªŒç°æœ‰æ•°æ®ã€‚
* **DEFAULT** â†’ ä»…å½±å“æ–°æ’å…¥è¡Œï¼Œä¸ä¼šä¿®æ”¹å·²æœ‰æ•°æ®ã€‚
* **çº¦æŸ** â†’ é»˜è®¤æ£€æŸ¥å…¨è¡¨æ•°æ®ï¼Œå¯ç”¨ `ENABLE NOVALIDATE` åªå¯¹æ–°æ•°æ®ç”Ÿæ•ˆã€‚

#### Referential Integrity
å½“ **çˆ¶è¡¨çš„ä¸»é”®è®°å½•è¢«åˆ é™¤**æ—¶ï¼Œå­è¡¨çš„å¤–é”®å¼•ç”¨å¯èƒ½ä¼šæœ‰ä¸åŒçš„å¤„ç†æ–¹å¼ã€‚Oracle æ”¯æŒä»¥ä¸‹å‡ ç§ç­–ç•¥ï¼š

---

1. RESTRICT ï¼ˆOracle é»˜è®¤ï¼šNO ACTIONï¼‰

* **å«ä¹‰**ï¼šå¦‚æœæŸä¸ªä¸»é”®åœ¨å­è¡¨ä¸­è¿˜æœ‰å¤–é”®å¼•ç”¨ï¼Œåˆ™ **ä¸å…è®¸åˆ é™¤** è¯¥ä¸»é”®è¡Œã€‚
* **ä¾‹å­**ï¼š

  * `DEPARTMENT.dept_no = 10`
  * `EMPLOYEE` è¡¨é‡Œè¿˜æœ‰å¤šè¡Œå‘˜å·¥çš„ `dept_no=10`
  * åˆ é™¤ `DEPARTMENT` è¡¨çš„ `dept_no=10` â†’ **æŠ¥é”™ï¼Œæ‹’ç»åˆ é™¤**ã€‚

---

2. CASCADE ï¼ˆçº§è”åˆ é™¤ï¼ŒOracle è¯­æ³•ï¼š`ON DELETE CASCADE`ï¼‰

* **å«ä¹‰**ï¼šåˆ é™¤çˆ¶è¡¨ï¼ˆä¸»é”®è¡¨ï¼‰çš„è¡Œæ—¶ï¼Œè‡ªåŠ¨åˆ é™¤å­è¡¨ä¸­å¯¹åº”çš„å¤–é”®è¡Œã€‚
* **ä¾‹å­**ï¼š

  * åˆ é™¤ `DEPARTMENT.dept_no=10` â†’ è‡ªåŠ¨æŠŠ `EMPLOYEE` è¡¨ä¸­æ‰€æœ‰ `dept_no=10` çš„è¡Œä¸€å¹¶åˆ é™¤ã€‚

---

3. NULLIFY ï¼ˆç½®ç©ºï¼ŒOracle è¯­æ³•ï¼š`ON DELETE SET NULL`ï¼‰

* **å«ä¹‰**ï¼šåˆ é™¤çˆ¶è¡¨çš„ä¸»é”®è¡Œæ—¶ï¼Œå­è¡¨ä¸­å¯¹åº”çš„å¤–é”®å­—æ®µä¼š **æ›´æ–°ä¸º NULL**ã€‚
* **ä¾‹å­**ï¼š

  * åˆ é™¤ `DEPARTMENT.dept_no=10` â†’ `EMPLOYEE` è¡¨ä¸­æ‰€æœ‰ `dept_no=10` çš„è¡Œä¼šå˜æˆ `dept_no=NULL`ã€‚

#### Referential Integrity ä¸­çš„åˆ é™¤ç­–ç•¥
| ç­–ç•¥                   | ä½¿ç”¨åœºæ™¯                                              | ç¤ºä¾‹                                                                                            | ä¼˜ç‚¹                               |
| ---------------------- | ----------------------------------------------------- | ----------------------------------------------------------------------------------------------- | ---------------------------------- |
| **ON DELETE CASCADE**  | å­è¡¨è®°å½• **å®Œå…¨ä¾èµ–çˆ¶è¡¨**ï¼Œçˆ¶è¡¨ä¸å­˜åœ¨æ—¶å­è¡¨ä¹Ÿåº”è¢«åˆ é™¤ | - è®¢å•ä¸»è¡¨ï¼ˆordersï¼‰ â†” è®¢å•æ˜ç»†è¡¨ï¼ˆorder_itemsï¼‰<br>- å­¦ç”Ÿè¡¨ï¼ˆstudentsï¼‰ â†” æˆç»©è¡¨ï¼ˆscoresï¼‰     | ä¿è¯æ•°æ®ä¸€è‡´æ€§ï¼Œä¸ä¼šç•™ä¸‹â€œå­¤å„¿è®°å½•â€ |
| **ON DELETE SET NULL** | å­è¡¨è®°å½• **å¯ç‹¬ç«‹å­˜åœ¨**ï¼Œä½†å¤–é”®å…³ç³»å¤±æ•ˆæ—¶éœ€è¦è§£é™¤å…³è” | - å‘˜å·¥è¡¨ï¼ˆemployeesï¼‰ çš„ `manager_id` â†” ç»ç†è¡¨<br>- å®¢æˆ·è¡¨ï¼ˆcustomersï¼‰ çš„æ¨èäººå­—æ®µ â†” æ¨èäººè¡¨ | ä¿ç•™å­è¡¨æ•°æ®ï¼Œä»…è§£é™¤å¤–é”®ä¾èµ–       |


#### Drop syntax
```sql
DROP TABLE table_name [CASCADE CONSTRAINTS] [PURGE];
-- CASCADE CONSTRAINTSï¼šåˆ é™¤è¯¥è¡¨çš„åŒæ—¶ï¼Œè‡ªåŠ¨åˆ é™¤ä¾èµ–å®ƒçš„å¤–é”®çº¦æŸã€‚
-- PURGEï¼šè·³è¿‡å›æ”¶ç«™ï¼Œå½»åº•åˆ é™¤è¡¨ï¼Œæ— æ³•é—ªå›æ¢å¤ã€‚
DROP INDEX index_name;
DROP VIEW view_name;
DROP USER user_name [CASCADE];
-- CASCADEï¼šåˆ é™¤ç”¨æˆ·çš„åŒæ—¶ï¼Œè¿åŒè¯¥ç”¨æˆ·ä¸‹çš„æ‰€æœ‰å¯¹è±¡ä¸€èµ·åˆ é™¤ã€‚
```
# Week 7 DML and Transaction Management

## DML

### COMMIT and ROLLBACK

- COMMIT: makes the changes to the database permanent
- ROLLBACK: will undo/remove the changes

| ç±»å‹                                    | å…¸å‹è¯­å¥                              | æ˜¯å¦ä¼šæäº¤äº‹åŠ¡       | è¯´æ˜                                          |
| --------------------------------------- | ------------------------------------- | -------------------- | --------------------------------------------- |
| **DMLï¼ˆData Manipulation Languageï¼‰**   | `INSERT`, `UPDATE`, `DELETE`, `MERGE` | âŒ ä¸ä¼šè‡ªåŠ¨æäº¤       | ä¿®æ”¹è¡¨ä¸­æ•°æ®ï¼Œéœ€æ˜¾å¼ `COMMIT` æˆ– `ROLLBACK`ã€‚ |
| **DDLï¼ˆData Definition Languageï¼‰**     | `CREATE`, `ALTER`, `DROP`, `TRUNCATE` | âœ… è‡ªåŠ¨æäº¤           | ä¿®æ”¹å¯¹è±¡ç»“æ„ï¼Œä¼šéšå¼æäº¤å‰åäº‹åŠ¡ã€‚            |
| **DCLï¼ˆData Control Languageï¼‰**        | `GRANT`, `REVOKE`                     | âœ… è‡ªåŠ¨æäº¤           | æ”¹å˜æƒé™æ§åˆ¶ï¼ŒåŒæ ·ä¼šéšå¼æäº¤ã€‚                |
| **TCLï¼ˆTransaction Control Languageï¼‰** | `COMMIT`, `ROLLBACK`, `SAVEPOINT`     | âœ… æ§åˆ¶äº‹åŠ¡æäº¤ä¸å›æ»š | æ§åˆ¶äº‹åŠ¡è¾¹ç•Œã€‚                                |


### Insert
```sql
-- insert single row
INSERT INTO table_name (column_list)
VALUES( value_list);

INSERT INTO table_name
VALUES (value_list);

-- insert multiple rows
INSERT INTO table_name (column_list)
VALUES 
   ( value_list_1),
   ( value_list_2),
   ( value_list_3);

COMMIT/ROLLBACK
```

If you exclude one or more columns from the Oracle `INSERT` statement, then you must specify the column list because Oracle needs it to match with values in the value list.

The column that you omit in the `INSERT` statement will use the default value if available or `NULL` if the column accepts NULL.

#### Inserting DATES into a table
```sql
INSERT INTO t_orders (id, order_dt)
VALUES (1, TO_DATE('2025-09-30 14:35:00', 'YYYY-MM-DD HH24:MI:SS'));
COMMIT/ROLLBACK

-- convert a date
TO_DATE('10 Dec 2022','dd Mon yyyy')
-- convert a datetime
TO_DATE('10/12/2022 17:00','dd/mm/yyyy hh24:mi')
-- convert a time
TO_DATE('17:00','hh24:mi')
```

å¸¸ç”¨çš„æ ¼å¼å…ƒç´ :
- year
    - YYYY -> 4 ä½å¹´ï¼ˆæœ€å¸¸ç”¨ï¼‰
    - YY â†’ 2 ä½å¹´
- month
    - MM â†’ æœˆä»½æ•°å­—ï¼ˆåˆ«å’Œ MI åˆ†é’Ÿæ··ï¼‰
    - MON â†’ è‹±æ–‡ç¼©å†™æœˆï¼ˆJan, Febâ€¦ å— NLS_DATE_LANGUAGE å½±å“ï¼‰
    - MONTH â†’ è‹±æ–‡å…¨åï¼ˆJanuaryâ€¦ï¼‰
- day
    - DD â†’ æœˆå†…ç¬¬å‡ å¤©ï¼ˆ01â€“31ï¼‰
    - DDD â†’ å¹´å†…ç¬¬å‡ å¤©ï¼ˆ001â€“366ï¼‰
- time
    - HH24 â†’ 24å°æ—¶åˆ¶å°æ—¶ï¼ˆ00â€“23ï¼‰
    - HH â†’ 12å°æ—¶åˆ¶å°æ—¶ï¼ˆ01â€“12ï¼‰
    - MI â†’ åˆ†é’Ÿï¼ˆ00â€“59ï¼‰
    - SS â†’ ç§’ï¼ˆ00â€“59ï¼‰
- am/pm
    - AM / PM â†’ é…åˆ HH ä½¿ç”¨ï¼ˆ12å°æ—¶åˆ¶ï¼‰
  
---

å¤§å°å†™ä¸æ•æ„Ÿ
åœ¨ Oracle ä¸­ï¼Œ**TO_DATE çš„æ ¼å¼æ©ç ï¼ˆformat modelï¼‰æ˜¯å¤§å°å†™ä¸æ•æ„Ÿï¼ˆcase-insensitiveï¼‰**çš„ã€‚
ä¹Ÿå°±æ˜¯è¯´ï¼š
```sql
YYYY == yyyy == Yyyy == yYyY
```
è™½ç„¶åŠŸèƒ½ä¸Šæ²¡åŒºåˆ«ï¼Œä½†åœ¨å®é™…å¼€å‘/è€ƒè¯•/ä½œä¸šä¸­  
ç»Ÿä¸€å†™æˆ å¤§å†™ï¼ˆYYYY-MM-DD HH24:MI:SSï¼‰ 

---

è¿æ¥ç¬¦ä¸æ–‡å­—  
æ ¼å¼ä¸­å¯ä»¥å†™å­—é¢é‡ï¼ˆå¦‚ -ã€/ã€ç©ºæ ¼ã€å›ºå®šå•è¯ï¼‰ï¼Œéœ€ä¸å­—ç¬¦ä¸²é€å­—ç¬¦å¯¹åº”ã€‚
```sql
TO_DATE('2025-10-18','YYYY-MM-DD')
TO_DATE('18 of Oct 2025','DD "of" MON YYYY')
TO_DATE('2025/10/18', 'YYYY-MM-DD');  -- ä¹Ÿ OKï¼ˆåˆ†éš”ç¬¦ä¸åŒä¹Ÿèƒ½åŒ¹é…ï¼‰
```
ä½¿ç”¨ FXï¼ˆExact matchï¼‰æ—¶ï¼Œæ‰€æœ‰å­—é¢é‡ã€ç©ºæ ¼ã€å¤§å°å†™å¿…é¡»å®Œå…¨åŒ¹é…ï¼š
```sql
TO_DATE('2025-10-18','FXYYYY-MM-DD') âœ…
TO_DATE('2025/10/18','FXYYYY-MM-DD') âŒ ï¼ˆåˆ†éš”ç¬¦ä¸åŒï¼‰
```

#### Using a SEQUENCE
```sql
CREATE SEQUENCE schema_name.sequence_name
[INCREMENT BY interval]
[START WITH first_number]
[MAXVALUE max_value | NOMAXVALUE]
[MINVALUE min_value | NOMINVALUE]
[CYCLE | NOCYCLE]
[CACHE cache_size | NOCACHE]
[ORDER | NOORDER];

sequence_name.nextval
sequence_name.currval

-- NEXTVAL ç¬¬ä¸€æ¬¡è¿”å›çš„å°±æ˜¯ START WITH
-- CURRVAL ä»…åœ¨å½“å‰ä¼šè¯ä¸”å·²è°ƒç”¨è¿‡ NEXTVAL åå¯ç”¨ï¼›å¦åˆ™æŠ¥ ORA-08002
-- CURRVAL æ‹¿åˆ°çš„æ˜¯æœ¬ä¼šè¯æœ€è¿‘ä¸€æ¬¡ NEXTVAL çš„å€¼ï¼Œä¸æ˜¯â€œå…¨åº“æœ€æ–°â€

-- ä¾‹å­ï¼š
-- åºåˆ—ï¼šä¸»é”®è‡ªå¢æ¥æº
CREATE SEQUENCE seq_emp_id
  START WITH 1
  INCREMENT BY 1
  CACHE 100;

-- ä¸»è¡¨ï¼šEMP
CREATE TABLE emp (
  id       NUMBER PRIMARY KEY,
  name     VARCHAR2(50) NOT NULL,
  hiredate DATE NOT NULL
);

-- ä»è¡¨ä¸¾ä¾‹1ï¼šå‘˜å·¥è¯¦æƒ…ï¼ˆå¤–é”®æŒ‡å‘ EMP.IDï¼‰
CREATE TABLE emp_detail (
  emp_id    NUMBER NOT NULL,
  address   VARCHAR2(200),
  phone     VARCHAR2(30),
  CONSTRAINT fk_emp_detail_emp
    FOREIGN KEY (emp_id) REFERENCES emp(id)
);

-- ä»è¡¨ä¸¾ä¾‹2ï¼šå‘˜å·¥æ—¥å¿—ï¼ˆå¤–é”®æŒ‡å‘ EMP.IDï¼‰
CREATE TABLE emp_log (
  emp_id    NUMBER NOT NULL,
  action    VARCHAR2(30) NOT NULL,
  action_ts TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  CONSTRAINT fk_emp_log_emp
    FOREIGN KEY (emp_id) REFERENCES emp(id)
);

-- æ’å…¥ä¸»è¡¨ï¼šç”¨ NEXTVAL ç”Ÿæˆæ–°ä¸»é”®
INSERT INTO emp (id, name, hiredate)
VALUES (seq_emp_id.NEXTVAL,
        'Alice',
        TO_DATE('2025-10-18 14:30:00','YYYY-MM-DD HH24:MI:SS'));

-- å¤ç”¨åˆšåˆšé‚£æ¬¡çš„ä¸»é”®ï¼šåŒä¸€ä¼šè¯å†…ä½¿ç”¨ CURRVAL
INSERT INTO emp_detail (emp_id, address, phone)
VALUES (seq_emp_id.CURRVAL, 'Melbourne, VIC', '0400-000-000');

INSERT INTO emp_log (emp_id, action)
VALUES (seq_emp_id.CURRVAL, 'CREATE');

COMMIT;
```

### Update
```sql
UPDATE
    table_name
SET
    column1 = value1,
    column2 = value2,
    column3 = value3,
    ...
WHERE
    condition;

-- subquery
UPDATE 
    target_table
SET 
    column1 = (
      SELECT value_column
        FROM source_table
      WHERE source_table.id = target_table.id
    )
WHERE EXISTS (
      SELECT value_column
        FROM source_table
      WHERE source_table.id = target_table.id
    );
```

### LOWER() and UPPER()
Since we cannot "know" the case of our data, SQL has two functions UPPER
and LOWER used to modify case:
```sql
SELECT * FROM table_name WHERE LOWER(column) = LOWER(value);
SELECT * FROM table_name WHERE UPPER(column) = UPPER(value);
```

### Delete
```sql
DELETE
FROM
    table_name
WHERE
    condition;

-- Deleting all rows from a table
DELETE FROM table_name;
```

## Transaction Management

### Transaction Properties
ğŸ“Œ Transaction Properties (äº‹åŠ¡ç‰¹æ€§)

åœ¨æ•°æ®åº“ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªäº‹åŠ¡å¿…é¡»å…·å¤‡ä»¥ä¸‹å››ä¸ªå±æ€§ï¼ˆACIDï¼‰ï¼š

1. Atomicityï¼ˆåŸå­æ€§ï¼‰

æ‰€æœ‰æ•°æ®åº“æ“ä½œï¼ˆSQLè¯·æ±‚ï¼‰å¿…é¡» å…¨éƒ¨å®Œæˆæˆ–å…¨éƒ¨ä¸åšã€‚

å¦‚æœäº‹åŠ¡ä¸­çš„ä»»ä½•ä¸€ä¸ªæ“ä½œå¤±è´¥ï¼Œåˆ™ä¹‹å‰çš„æ‰€æœ‰æ“ä½œéƒ½å¿…é¡»å›æ»šï¼ˆæ’¤é”€ï¼‰ã€‚

2. Consistencyï¼ˆä¸€è‡´æ€§ï¼‰

äº‹åŠ¡å¿…é¡»ä½¿æ•°æ®åº“ä»ä¸€ä¸ªä¸€è‡´çŠ¶æ€å˜æ¢åˆ°å¦ä¸€ä¸ªä¸€è‡´çŠ¶æ€ã€‚

ä¿è¯äº‹åŠ¡å‰åæ•°æ®çš„å®Œæ•´æ€§çº¦æŸä¸è¢«ç ´åã€‚

3. Isolationï¼ˆéš”ç¦»æ€§ï¼‰

äº‹åŠ¡åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¸åº”å—åˆ°å…¶ä»–å¹¶å‘äº‹åŠ¡çš„å¹²æ‰°ã€‚

æŸä¸ªäº‹åŠ¡åœ¨æ‰§è¡Œæ—¶æ‰€ä½¿ç”¨çš„æ•°æ®åœ¨å…¶å®Œæˆå‰ä¸åº”è¢«å…¶ä»–äº‹åŠ¡è®¿é—®ã€‚

4. Durabilityï¼ˆæŒä¹…æ€§ï¼‰

ä¸€æ—¦äº‹åŠ¡æäº¤ï¼Œæ‰€åšçš„ä¿®æ”¹å°±æ˜¯æ°¸ä¹…æ€§çš„ã€‚

å³ä½¿ç³»ç»Ÿå‘ç”Ÿæ•…éšœï¼Œå·²æäº¤çš„æ•°æ®ä¹Ÿä¸ä¼šä¸¢å¤±ã€‚

### Transaction Management

- Follows the ACID properties
- Transaction boundaries
    - Start
        - first SQL statement is executed (eg. Oracle)
        - Some systems have a BEGIN WORK type command
    - End
        - COMMIT or ROLLBACK
- Concurrency Management
- Restart and Recovery

### Concurrency Management

- Locking mechanism
    - Shared lock
    - Exclusive lock

### Deadlock

- Dealing with deadlock
    - Deadlock prevention
    - Deadlock avoidance
    - Deadlock detection and recovery

### Database Recovery

- Transaction Log
    - Record for beginning of transaction
    - Type of operation being performed (update, delete, insert)
    - Names of objects affected by the transaction (the name of the table)
    - â€œBeforeâ€ and â€œafterâ€ values for updated fields
    - Pointers to previous and next transaction log entries for the same transaction
    - The ending (COMMIT) of the transaction
- Checkpoint
    - Accepting new transactions is temporarily halted, and current transactions are suspended.
    - Results of committed transactions are made permanent (force-written to the disk).
    - A checkpoint record is written in the log.
    - Execution of transactions is resumed.

- Software Crash Recovery
    - Write Through
        1. æ„å»º REDO å’Œ UNDO åˆ—è¡¨

            - æ ¹æ®æ—¥å¿—ï¼Œä»**æœ€è¿‘çš„æ£€æŸ¥ç‚¹ï¼ˆCheckpointï¼‰**å¼€å§‹å‘å‰è¯»å–ï¼Œæ„å»ºä¸¤ä¸ªåˆ—è¡¨ï¼š
                - **REDO list**ï¼šåŒ…å«æ‰€æœ‰ **å·²æäº¤äº‹åŠ¡** çš„ Transaction IDã€‚
                - **UNDO list**ï¼šåŒ…å«æ‰€æœ‰ **æœªå®Œæˆï¼ˆæœªæäº¤æˆ–å·²å›æ»šï¼‰äº‹åŠ¡** çš„ Transaction IDã€‚

        2. UNDO æœªå®Œæˆäº‹åŠ¡ï¼ˆä»æœ€è¿‘å¼€å§‹ï¼‰

            - å¯¹ `UNDO list` ä¸­çš„äº‹åŠ¡æŒ‰**é€†åºï¼ˆä»æ–°åˆ°æ—§ï¼‰**å¤„ç†ï¼›
            - ä½¿ç”¨ **before imageï¼ˆå˜æ›´å‰æ•°æ®ï¼‰** è¿›è¡Œ **ROLLBACK**ï¼›
            - ç›®çš„æ˜¯æ’¤é”€æœªæäº¤äº‹åŠ¡å¯¹æ•°æ®åº“çš„å½±å“ã€‚

        3. REDO å·²æäº¤äº‹åŠ¡ï¼ˆä»æœ€æ—©å¼€å§‹ï¼‰

            - å¯¹ `REDO list` ä¸­çš„äº‹åŠ¡æŒ‰**é¡ºåºï¼ˆä»æ—§åˆ°æ–°ï¼‰**å¤„ç†ï¼›
            - ä½¿ç”¨ **after imageï¼ˆå˜æ›´åæ•°æ®ï¼‰** è¿›è¡Œ **ROLLFORWARD**ï¼›
            - ç›®çš„æ˜¯é‡åšå·²æäº¤äº‹åŠ¡çš„æ“ä½œï¼Œç¡®ä¿æŒä¹…åŒ–å®Œæˆã€‚

    - Deferred Write
        1. æ•°æ®åº“åªåœ¨äº‹åŠ¡æäº¤ï¼ˆCOMMITï¼‰ä¹‹åæ‰å†™å…¥ç£ç›˜
            - æ‰€æœ‰æ›´æ”¹é¦–å…ˆä¿å­˜åœ¨å†…å­˜ä¸­ï¼ˆå¦‚ redo log bufferï¼‰ï¼›
            - åªæœ‰åœ¨äº‹åŠ¡çœŸæ­£æäº¤ä¹‹åï¼Œæ‰å°†æ›´æ”¹æ•°æ®å†™å…¥æ•°æ®åº“çš„æ•°æ®æ–‡ä»¶ï¼›
            - åœ¨å´©æºƒå‰æœªæäº¤çš„äº‹åŠ¡æ›´æ”¹ **æ ¹æœ¬ä¸ä¼šå†™å…¥ç£ç›˜**ã€‚

        2. åªéœ€ **Redoï¼ˆé‡åšï¼‰å·²æäº¤äº‹åŠ¡**
            - å´©æºƒæ¢å¤æ—¶åªéœ€è¦å°†å·²æäº¤äº‹åŠ¡çš„æ›´æ”¹é‡æ–°åº”ç”¨ï¼ˆroll forwardï¼‰ï¼›
            - **æ— éœ€å›æ»šæœªæäº¤äº‹åŠ¡**ï¼Œå› ä¸ºå®ƒä»¬æ ¹æœ¬æœªå†™å…¥ç£ç›˜ï¼ˆä¸å­˜åœ¨â€œè„å†™â€ï¼‰ï¼›
            - ç›¸æ¯” Write Through ç­–ç•¥ï¼Œæ­¤ç­–ç•¥çš„æ¢å¤æ›´ç®€å•å¿«é€Ÿã€‚

# Week 8 SQL Part I

##  SQL statement, clause, predicate

**Anatomy**

```sql
SELECT <select_list>
FROM   <table_or_joins>
WHERE  <predicate>
[ORDER BY <expr> [ASC|DESC] [NULLS FIRST|LAST]]
```

* A **predicate** is any Boolean expression in `WHERE` (also in `JOIN ... ON`, `HAVING`, `CASE WHEN`, etc.).
* Oracle evaluates the predicate **per row** using **threeâ€‘valued logic**: `TRUE`, `FALSE`, `UNKNOWN` (NULL involved).
* Only rows where the predicate evaluates to **TRUE** are returned.

---

## Writing SQL predicates

### Comparison operators

`>`, `<`, `=`, `<>` (preferred), `!=`, `>=`, `<=`

**Notes**

* Any comparison with `NULL` is `UNKNOWN` (except `IS NULL` / `IS NOT NULL`).
* Character comparisons use session collation rules; for safe caseâ€‘insensitive search, use `UPPER(col) = UPPER(:val)` or `REGEXP_LIKE(col, :val, 'i')`.

**Examples**

```sql
WHERE salary >= 120000
WHERE last_name <> 'Smith'
WHERE start_dt < DATE '2025-01-01'
```

### Range: `BETWEEN`

* Syntax: `expr BETWEEN low AND high`
* **Inclusive** of both ends.

```sql
WHERE order_total BETWEEN 100 AND 200  -- 100 â‰¤ order_total â‰¤ 200
```

**Date tip**: For fullâ€‘day ranges prefer **halfâ€‘open** windows to avoid time parts:

```sql
WHERE order_dt >= DATE '2025-10-01'
  AND order_dt <  DATE '2025-11-01'
```

### Set membership: `IN`

```sql
WHERE status IN ('NEW','PENDING','HOLD')
```

**Pitfall**: `NOT IN` with a list containing `NULL` yields **no rows** (predicate becomes `UNKNOWN`). Prefer `NOT EXISTS` or filter out NULLs in the subquery.

### Pattern matching: `LIKE` and `REGEXP_LIKE`

* `LIKE` wildcards: `%` (0+ chars), `_` (single char).
* Use `ESCAPE '\'` to treat wildcard chars literally.

```sql
WHERE name LIKE 'SMI%'
WHERE code LIKE 'A\_%' ESCAPE '\'  -- matches A_*
-- Caseâ€‘insensitive, flexible patterns:
WHERE REGEXP_LIKE(email, '\\.(edu|org)$', 'i')
```

### NULL checks: `IS NULL`

```sql
WHERE cancelled_dt IS NULL
WHERE cancelled_dt IS NOT NULL
```

### Subquery predicates: `ANY`, `ALL`, `EXISTS`

* `> ANY (subq)`: greater than **at least one** value (i.e., `> MIN(...)`).
* `> ALL (subq)`: greater than **every** value (i.e., `> MAX(...)`).
* `EXISTS (correlated_subq)`: true if subquery returns **any** row; **ignores NULLs** inside.

```sql
-- Price higher than at least one competitor
WHERE price > ANY (SELECT competitor_price FROM price_survey)

-- Price higher than all competitors
WHERE price > ALL (SELECT competitor_price FROM price_survey)

-- Has at least one active rental
WHERE EXISTS (
  SELECT 1
  FROM   drone.rental r
  WHERE  r.drone_id = d.drone_id
  AND    r.rent_in_dt IS NULL
)
```

---

## Combining predicates

### Logical operators & precedence

* Operators: `NOT` > `AND` > `OR` (use parentheses to be explicit).

### Truth tables (threeâ€‘valued logic)

**AND**

| A \ B | **T** | **U** | **F** |
| :---- | :---: | :---: | :---: |
| **T** |   T   |   U   |   F   |
| **U** |   U   |   U   |   F   |
| **F** |   F   |   F   |   F   |

**OR**

| A \ B | **T** | **U** | **F** |
| :---- | :---: | :---: | :---: |
| **T** |   T   |   T   |   T   |
| **U** |   T   |   U   |   U   |
| **F** |   T   |   U   |   F   |

**NOT**

|  A  | NOT A |
| :-: | :---: |
|  T  |   F   |
|  U  |   U   |
|  F  |   T   |

---

## Arithmetic in SQL

* Operators: `+`, `-`, `*`, `/`.
* **Any arithmetic with `NULL` â†’ `NULL`** (use `NVL`/`COALESCE` if needed).
* Division by zero raises `ORA-01476`.
* Date arithmetic: `DATE + n` adds **n days**; subtracting two `DATE`s returns **number of days** (`NUMBER`).

```sql
SELECT (salary + NVL(bonus,0)) AS total_pay
FROM   employees;

SELECT SYSDATE + 7 AS one_week_from_now FROM dual;    -- +7 days
SELECT (DATE '2025-10-31' - DATE '2025-10-01') AS days_span FROM dual;  -- 30
```

---

## Handling NULLs â€” `NVL` and friends

### `NVL(expr1, expr2)`

Replaces `NULL` with a value. **Both arguments must be the same datatype** or implicitly convertible.

> è§„åˆ™ï¼šä¸¤ä¸ªå‚æ•°ï¼ˆ`expr1` ä¸ `expr2`ï¼‰å¿…é¡»æ˜¯ç›¸åŒæ•°æ®ç±»å‹ï¼Œæˆ–è€… Oracle èƒ½å¤Ÿéšå¼è½¬æ¢æˆåŒä¸€ç±»å‹ã€‚

```sql
NVL(enrolmark, 0)
NVL(enrolgrade, 'WH')
```

### Related functions (know when to prefer)

* `NVL2(expr, value_if_not_null, value_if_null)`
* `COALESCE(a,b,c,...)` â€” returns first nonâ€‘NULL; **ANSI** and variadic; often preferable in portable SQL.
* `CASE WHEN expr IS NULL THEN ... ELSE ... END` â€” for complex logic.

```sql
SELECT COALESCE(nick_name, first_name, 'N/A') AS display_name FROM users;
```

---

## Column aliases

* Syntax: `expr AS alias` (keyword `AS` is optional in Oracle).
* Aliases are usable in `ORDER BY`, **not** in `WHERE` of the same SELECT.

```sql
SELECT salary * 12 AS annual_salary
FROM   employees
ORDER BY annual_salary DESC;  -- valid
```

---

## Ordering (sorting) results

* `ORDER BY <expr> [ASC|DESC]` (default **ASC**).
* Control placement of NULLs: `NULLS FIRST` | `NULLS LAST`.
* Oracle defaults: in **ASC**, NULLs sort **LAST**; in **DESC**, NULLs sort **FIRST**.

```sql
ORDER BY last_name ASC NULLS LAST,
         hire_date DESC NULLS FIRST;
```

---

## Removing duplicate rows

* `SELECT DISTINCT ...` removes **duplicate rows across the entire select list**.
* Be deliberateâ€”`DISTINCT` can be expensive; consider `GROUP BY` when aggregating.

```sql
SELECT DISTINCT department_id FROM employees;
```

---

## Joining tables (ANSI JOINs â€” required)

> For assessment: **do not** place joins in the `WHERE` clause; use ANSI join syntax.

### Join types & patterns

```sql
-- Inner join
SELECT e.emp_id, d.dept_name
FROM   employees e
JOIN   departments d
  ON   d.dept_id = e.dept_id;

-- Left outer join
SELECT e.emp_id, d.dept_name
FROM   employees e
LEFT JOIN departments d
  ON   d.dept_id = e.dept_id;

-- Full outer join
SELECT e.emp_id, d.dept_name
FROM   employees e
FULL OUTER JOIN departments d
  ON   d.dept_id = e.dept_id;

-- Cross join (Cartesian)
SELECT e.emp_id, p.perm
FROM   employees e
CROSS JOIN perms p;
```

### `USING` vs `ON`

* `USING(col)` autoâ€‘matches sameâ€‘named columns and **returns one copy** of the column.
* `ON` allows arbitrary join expressions and keeps both columns (qualify names).

```sql
SELECT *
FROM   orders o
JOIN   customers c
USING (customer_id);
```

### `NATURAL` JOIN (use sparingly)

* Automatically joins on **all columns with matching names**. Can break if schema changes. Prefer `USING`/`ON` for clarity.

---

## Oracle date & time

### Types

* `DATE` â€” stores **date + time to seconds**.
* `TIMESTAMP` â€” higher precision; `TIMESTAMP WITH TIME ZONE` / `WITH LOCAL TIME ZONE` add TZ semantics.

### Current date/time

* `SYSDATE` (type `DATE`) â€” DB server clock.
* `CURRENT_DATE` (type `DATE`) â€” session time zone.
* `SYSTIMESTAMP` / `CURRENT_TIMESTAMP` â€” timestamp variants.
* `USER` â€” current schema name; also `SESSIONTIMEZONE`, `DBTIMEZONE` if needed.

### Formatting & parsing

* Display with `TO_CHAR(expr, 'fmt')`; parse with `TO_DATE(text, 'fmt')` or ANSI literals.
* Prefer **ANSI literals** to avoid NLS issues:

  * `DATE 'YYYY-MM-DD'`
  * `TIMESTAMP 'YYYY-MM-DD HH24:MI:SS'`

```sql
SELECT rent_no,
       drone_id,
       TO_CHAR(rent_out_dt, 'DD-Mon-YYYY') AS date_out,
       NVL(TO_CHAR(rent_in_dt, 'DD-Mon-YYYY'), 'Still out') AS date_in
FROM   drone.rental;
```

### Date arithmetic helpers

* Truncate time: `TRUNC(dt)` (to day) or `TRUNC(dt, 'MM')` (to month).
* Add months: `ADD_MONTHS(dt, n)`; month diff: `MONTHS_BETWEEN(a,b)`.
* Intervals: `NUMTODSINTERVAL(n,'DAY'|'HOUR'|...)`, `NUMTOYMINTERVAL`.

---

## Worked subquery patterns

### `EXISTS` vs `IN`

```sql
-- Customers who have at least one rental
SELECT c.customer_id, c.name
FROM   customers c
WHERE  EXISTS (
  SELECT 1 FROM drone.rental r
  WHERE  r.customer_id = c.customer_id
);

-- Customers with a rental on specific day (using halfâ€‘open range)
SELECT c.customer_id, c.name
FROM   customers c
WHERE  EXISTS (
  SELECT 1 FROM drone.rental r
  WHERE  r.customer_id = c.customer_id
  AND    r.rent_out_dt >= DATE '2025-10-01'
  AND    r.rent_out_dt <  DATE '2025-10-02'
);
```

### `ANY` / `ALL`

```sql
-- Drones heavier than all drones in model X
SELECT d.drone_id
FROM   drone.inventory d
WHERE  d.weight_kg > ALL (
  SELECT weight_kg FROM drone.inventory WHERE model = 'X'
);
```

---

## Common pitfalls & best practices

* âœ… Use **ANSI JOIN** syntax; avoid old `WHERE` join style.
* âœ… Write **halfâ€‘open** date ranges (`>= start AND < next_day`) to avoid timeâ€‘component bugs.
* âœ… Be explicit with parentheses around complex `AND/OR` logic.
* âœ… Prefer `COALESCE` for portability; use `NVL` when you need Oracleâ€‘specific semantics.
* âš ï¸ `NOT IN (subq)` where subq returns `NULL` causes no rows; use `NOT EXISTS`.
* âš ï¸ Comparisons with `NULL` are `UNKNOWN`; use `IS NULL` / `IS NOT NULL`.
* âš ï¸ Donâ€™t rely on implicit type conversions; use proper literals (`DATE 'YYYY-MM-DD'`).
* âš ï¸ `DISTINCT` deâ€‘dupes across the **whole** select list; can mask data issues and impact performance.
* âš ï¸ Alias visibility: usable in `ORDER BY`, not in `WHERE`.

---

## Quick reference (copyâ€‘ready)

```sql
-- Inclusive between
col BETWEEN :low AND :high

-- Halfâ€‘open date window
col >= DATE '2025-10-01' AND col < DATE '2025-11-01'

-- LIKE with escape
col LIKE 'A\_%' ESCAPE '\'

-- Nullâ€‘safe arithmetic
NVL(col, 0)

-- EXISTS (ignores NULLs inside)
EXISTS (SELECT 1 FROM t WHERE t.k = s.k)

-- ANY / ALL
x > ANY (SELECT y FROM t)  -- x > MIN(y)
x > ALL  (SELECT y FROM t) -- x > MAX(y)

-- Sort with explicit NULL placement
ORDER BY score DESC NULLS LAST
```

# Week 9 SQL Intermediate

## Aggregate Functions

- COUNT
- MAX
- MIN
- SUM
- AVG

```sql
SELECT
MAX(drone_flight_time)
FROM
drone.drone;

SELECT
MIN(drone_flight_time)
FROM
drone.drone;

SELECT
AVG(drone_flight_time)
FROM
drone.drone;

SELECT COUNT(*)
FROM drone.drone
WHERE drone_flight_time > 100;
```

---

> count(\*) and count(column_name)  
> count(\*)ç»Ÿè®¡çš„æ˜¯æ‰€æœ‰çš„è®°å½•ï¼Œä¸å—ä»»ä½•åˆ—æ˜¯å¦ä¸º NULL å½±å“  
> åœ¨oracleä¸­count(1)ç­‰ä»·äºcount(*)  
> count(column_name)åªç»Ÿè®¡è¯¥åˆ—é NULL çš„è¡Œæ•°

## GROUP BY

```sql
SELECT
  *
FROM table_name
GROUP BY column_name
```

å½“group byå’Œèšåˆå‡½æ•°ä¸€èµ·ä½¿ç”¨çš„æ—¶å€™  
- group byå†³å®šäº†å¦‚ä½•è¿›è¡Œåˆ†ç»„
- èšåˆå‡½æ•°åœ¨æ¯ä¸ªåˆ†ç»„å†…è¿›è¡Œè®¡ç®—

---

group byä¸­åˆ—çš„é¡ºåºå¯ä»¥éšæ„è°ƒæ¢ï¼Œæœ€ååˆ†ç»„çš„ç»“æœæ˜¯ä¸€æ ·çš„
order byä¸­åˆ—çš„é¡ºåºä¸èƒ½éšæ„è°ƒæ¢ï¼Œæœ€åçš„æ’åºç»“æœä¼šä¸ä¸€æ ·

---

group byä¸­ä¸èƒ½ä½¿ç”¨alias  
order byä¸­å¯ä»¥ä½¿ç”¨alias  

oracleä¸­SQLçš„æ‰§è¡Œé¡ºåº:  
1. FROM/JOIN
2. WHERE
3. GROUP BY
4. Aggregate Functions
5. HAVING
6. SELECT
7. ORDER BY

åˆ°ç¬¬å…­æ­¥çš„selectæ‰ä¼šåº”ç”¨alias  
åˆ°ç¬¬ä¸ƒæ­¥çš„order byæ‰å¯ä»¥ä½¿ç”¨alias

---

GROUP BY å­å¥ä¸­çš„åˆ—ä¸ä¸€å®šå¿…é¡»å‡ºç°åœ¨ SELECT é‡Œ  
ä½†æ˜¯ï¼ŒSELECT é‡Œçš„éèšåˆåˆ—å¿…é¡»å‡ºç°åœ¨ GROUP BY ä¸­  

éèšåˆåˆ—æŒ‡çš„æ˜¯ SELECT ä¸­ç›´æ¥å‡ºç°çš„æ™®é€šåˆ—ï¼ˆæ²¡æœ‰æ”¾è¿›èšåˆå‡½æ•°é‡Œçš„åˆ—ï¼‰ 

```sql
SELECT deptno, COUNT(*)
FROM emp
GROUP BY deptno;   -- âœ… æ­£ç¡®

SELECT deptno, job, COUNT(*)
FROM emp
GROUP BY deptno;   -- âŒ é”™è¯¯ï¼Œjob ä¸æ˜¯èšåˆåˆ—ï¼Œä¹Ÿä¸åœ¨ GROUP BYé‡Œ
```

## HAVING

```sql
SELECT group_by_column, aggregate_function(column)
FROM table_name
[WHERE condition]         -- åˆ†ç»„å‰è¿‡æ»¤ï¼ˆè¡Œçº§è¿‡æ»¤ï¼‰
GROUP BY group_by_column
HAVING aggregate_condition -- åˆ†ç»„åè¿‡æ»¤ï¼ˆç»„çº§è¿‡æ»¤ï¼‰
[ORDER BY ...];
```

## Subqueries

1. whereå­å¥é‡Œçš„å­æŸ¥è¯¢ï¼ˆæœ€å¸¸è§ï¼‰

    ```sql
    -- æ ‡é‡å­æŸ¥è¯¢ï¼ˆè¿”å›å•ä¸ªå€¼ï¼‰
    SELECT ename, sal
    FROM emp
    WHERE sal > (SELECT AVG(sal) FROM emp);   

    -- å¤šè¡Œå­æŸ¥è¯¢ï¼ˆé…åˆ IN/EXISTS/ANY/ALLï¼‰
    SELECT ename, deptno
    FROM emp
    WHERE deptno IN (SELECT deptno FROM dept WHERE loc = 'NEW YORK');
    ```
2. fromå­å¥é‡Œçš„å­æŸ¥è¯¢

    ```sql
    -- å­æŸ¥è¯¢ç»“æœä½œä¸ºä¸€å¼  ä¸´æ—¶è¡¨ã€‚
    SELECT d.dname, t.avg_sal
    FROM (SELECT deptno, AVG(sal) AS avg_sal
          FROM emp
          GROUP BY deptno) t
    JOIN dept d ON t.deptno = d.deptno;
    ```
3. selectå­å¥é‡Œçš„å­æŸ¥è¯¢

    ```sql
    -- å­æŸ¥è¯¢è¿”å›ä¸€ä¸ªå€¼ï¼Œä½œä¸ºç»“æœé›†ä¸­çš„ä¸€åˆ—ã€‚
    SELECT e.ename,
         (SELECT d.dname 
          FROM dept d 
          WHERE d.deptno = e.deptno) AS dept_name
    FROM emp e;
    ```

### Types of Subqueries

1. å•å€¼å­æŸ¥è¯¢
2. å¤šè¡Œå­æŸ¥è¯¢
3. å¤šåˆ—å­æŸ¥è¯¢

### Comparison Operators for Subquery

- Operator for single value comperation
    =, <, >
- Operator for multiple rows or a list comperation
  IN
  ALL, ANY combined with <, >

---

1. ANY
  - \> ANY ç­‰ä»·äºå¤§äºæœ€å°å€¼
  - < ANY ç­‰ä»·äºå°äºæœ€å¤§å€¼
2. ALL
  - \> ALL ç­‰ä»·äºå¤§äºæœ€å¤§å€¼
  - < ALL ç­‰ä»·äºå°äºæœ€å°å€¼

# Week 10 SQL Advanced

## CASE

## Subquery â€“ nested, inline, correlated

## Views

## Joins - self join, outer join

## Set Operators

## Oracle Functions

# Week 11 Non Relational Databases

## Big Data Characteristics
## NoSQL Data Models
## NoSQL Databases
## MongonDB
### Create
### RETRIEVE
### UPDATE
### DELETE

# Week 12 BI, Data Warehousing and Legal/Ethical Issues
workshop used for test  
no recording  
pass