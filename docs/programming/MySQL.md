# MySQL

## 初识MySQL

MySQL采用客户端/服务器架构,用户通过客户端程序发送增删改查请求,服务器程序收到请求后处理,并把处理结果返回给客户端.

---

MySQL安装目录的bin目录下存放了许多可执行文件,其中有一些是服务器程序(比如mysqld,mysqld_safe),有一些是客户端程序(比如mysql,mysqladmin).

在类UNIX系统上启动服务器程序的方式有下面这些:

- mysqld;
- mysqld_safe;
- mysql.server;
- mysqld_multi;

在Windows系统上启动服务器程序的方式有下面这些:

- mysqld;
- 将mysqld注册为Windows服务,用net start 服务名 启动

启动客户端程序的常用语法如下:

```sql
mysql -h 主机名 -u 用户名 -p 密码
```

---

客户端进程和服务器进程在通信时采用下面几种方式:

- TCP/IP
- 命名管道或共享内存(Windows)
- UNIX域套接字

---

以查询请求为例,服务器程序在处理客户端发送过来的请求时,大致分为一下几个部分:

- 连接管理: 主要负责连接的连理与信息的认证
- 解析与优化: 主要进行查询缓存,语法解析,查询优化
- 存储引擎: 主要负责读取和写入底层表中的数据

为了方便管理,通常把连接管理和解析优化划分为server层,把存取真实数据的功能划分为存储引擎层.

---

MySQL支持的存储引擎有很多,其中最常用的是InnoDB和MyISAM,InnoDB是MySQL的默认存储引擎

- 查看当前服务器程序支持的存储引擎:

```sql
SHOW ENGINES;
```

- 创建表时指定表的存储引擎:

```sql
CREATE TABLE TABLENAME(
    # 创建语句
) ENGINE = 存储引擎的名字;
```

- 修改表的存储引擎:

```sql
ALTER TABLE TABLENAME ENGINE = 存储引擎的名字;
```

### 存储引擎

|   异同   | InnoDB | MyISAM |
| :-----: | :-----: | :-----: |
| 事务 | 支持 | 不支持 |
| 外键 | 支持 | 不支持 |
| 锁级别 | 行锁 | 表锁 |
| MVCC | 支持 | 不支持 |
| 全文索引 | 不支持 | 支持 |
| 在线热备份 | 支持 | 不支持 |

!> InnoDB 存储引擎开始支持全文索引是在 MySQL 5.6 版本中。在此之前，全文索引只能由 MyISAM 存储引擎支持。

## MySQL的启动选项和系统变量

启动选项可以调整服务器启动后的一些行。它们可以在命令行中指定，也可以将它们写入配置文件中

## 字符串和比较规则

字符集指的是某个字符范围的编码规则
比较规则是对某个字符集中字符比较大小的一种规则
在MySQL中一个字符集可以有若干种比较规则，其中有一个默认的比较规则。一个比较规则必须对应一个字符集。

字在MySQL中查看支持的字符集和比较规则的语句如下：

```sql
SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];
SHOW COLLATION [LIKE 匹配的模式];
```

MySQL有四种级别的字符集和比较规则：

- 服务器级别
- 数据库级别
- 表级别
- 列级别

从发送请求到接受响应的过程中发生的字符集转换如下：

系统变量及其含义：

## InnoDB记录存储结构

### 行结构

InnoDB存储引擎是面向行的，也就是说数据是按行进行存放的，按行存放的数据便是一条条的记录，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。目前InnoDB中共有4中不同类型的行格式，分别为Compact、Redundant、Dynamic和Compressed行格式。

- Redundant：这是MySQL 5.0.3之前版本的默认行格式。每一行都有一个额外的字节，用于存储null值的信息。

- Compact：这是MySQL 5.0.3及更高版本的默认行格式。与Redundant格式相比，Compact格式使用更少的存储空间。它使用更紧凑的方式存储null值和变长字段。

- Dynamic：这是MySQL 5.7及更高版本的默认行格式。与Compact格式相比，Dynamic格式更有效地管理BLOB，TEXT，VARCHAR等变长字段。如果这些字段的长度超过768字节，Dynamic格式只在主页中存储768字节的前缀，剩余的部分存储在溢出页中。

- Compressed：这种格式与Dynamic格式类似，但它会对数据进行压缩，以节省存储空间。这需要在表空间级别启用压缩。

>在MySQL 5.7及更高版本中，InnoDB的默认行格式是DYNAMIC  
>在MySQL 5.6及更低版本中，InnoDB的默认行格式是COMPACT

记录头信息中的详细信息
| 名称     | 大小 | 描述 |
| :------: | :------: | :------: |
|   Text   |   Text   |   Text   |
|   Text   |   Text   |   Text   |
|   Text   |   Text   |   Text   |
|   Text   |   Text   |   Text   |
|   Text   |   Text   |   Text   |
|   Text   |   Text   |   Text   |
|   Text   |   Text   |   Text   |
|   Text   |   Text   |   Text   |

<div class="center">
    <table>
    <th>
        <td align="center" colspan="3">记录的额外信息</td>
        <td align="center" colspan="6">记录的真实信息</td>
    </th>
    <tr>
        <td>变长字段长度列表</td>
        <td>NULL值列表</td>
        <td>记录头信息</td>
        <td>DB_ROW_ID</td>
        <td>DB_TRX_ID</td>
        <td>DB_ROLL_PTR</td>
        <td>列1的值</td>
        <td>...</td>
        <td>列n的值</td>
    </tr>
    </table>
</div>

以compact格式为例：一行数据结构如上图，分为额外信息和真实的列值数据两部分，额外信息中需要记录变长列的长度，因为是变长的无法提前知道长度，所以需要随着每条记录做标记；null值列表主要是null不会在数据部分做任何存储，只在这里存储列名；记录头信息内容比较多，比如有指向下一条记录的指针，deleted标等。

一行数据不能太长，最长是700多个字节，超出的部分就算溢出，当前数据记录一个指针，超出的部分单独放到溢出页，指针指过去，可能有多个溢出的列。

## InnoDB数据页结构

### 数据页结构块览

InnoDB存储引擎的数据是基于页（Page）的，页是InnoDB管理存储空间的基本单位，也是InnoDB中磁盘和内存交互的基本单位，每个页的大小默认为16KB，可以在初始化数据库时进行设置。每个页中包含了许多行数据以及其他的一些控制信息。

InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的也成为数据页  
一个InnoDB的数据页的结构大致如下：

<div class="center">

| 名称                  | 中文名 | 占用空间大小 | 简单描述|
|      :------:         | :------: | :------: | :------: |
|    File Header        | 文件头部 | 38字节 | 页的通用信息 |
|    Page Header        | 页面头部 | 56字节 | 数据页专用信息 |
|    Infimum+Supremum   | 页面中的最小记录和最大记录 | 26字节 | 两个虚拟的记录 |
|    User Records       | 用户记录 | 不确定 | 用户存储的记录内容 |
|    Free Space         | 空闲记录 | 不确定 | 页中尚未使用的空间 |
|    Page Directory     | 页目录  | 不确定 | 页中某些记录的相对位置 |
|    File Trailer       | 文件尾部 | 8字节 | 校验页是否完整 |

</div>

- **File Header**：包含了该页的一些通用信息，如页类型、上一个页的位置（prev）、下一个页的位置（next）等，占用固定的38字节

- **Page Header**：包含了该页的一些专用信息，如记录的数量、记录的目录开始位置等，占用固定的56字节

- **Infimum+Supremum Records**：两个特殊的记录，用于在页内形成一个记录的双向链表。  
Infimum Record：这是一个虚拟记录，它的值小于页中任何实际记录的值。Infimum记录存在于每个页中，用于初始化页的开始部分，并作为记录链表的起点。  
Supremum Record：这也是一个虚拟记录，它的值大于页中任何实际记录的值。Supremum记录存在于每个页中，用于初始化页的结束部分，并作为记录链表的终点。
占用固定的26字节

- **User Records**：用户的记录，即实际的行数据，大小不固定

- **Free Space**：未使用的空间，大小不固定

- **Page Directory**：记录的目录，页中某些记录的相对位置，也就是各个槽对应的记录在页面中的地址偏移量，用于加速对记录的查找，大小不固定，插入的记录越多，这个部分占用的空间就越多

- **File Trailer**：页的尾部，主要是一些校验信息，用于验证页是否完整，占用固定的8字节

每个记录的头信息中都有一个next_record属性，从而可以是页中的所有记录串成一个单向列表

InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，一个槽占用2字节。在一个页中根据主键查找记录是非常快的，分为两步：

1. 通过二分法确定该记录所在的分组对应的槽，并找到该槽所在分组中主键值最小的那条记录
2. 通过记录的next_record属性遍历该槽所在的组中的各个记录

每个数据页的File Header部分都有上一个页和下一个页的编号，所以所有的数据页会组成一个双向链表

在将页刷新到磁盘时，为了保证页的完整性，页首和页尾都会存储也中的数据校验和，以及页面最后修改是对应的LSN值（页尾只会存储LSN值的后4字节）。如果页首和页尾的校验和以及LSN值校验不成功，就说明刷新期间出来问题。

## B+树索引的使用

### B+树索引

回表

索引下推（Index Condition Pushdown, ICP）：索引下推是一种优化方法，其中查询的一部分条件被推送到索引层，以减少从存储引擎到MySQL服务器的数据传输。
使用explain语句之后如果 Extra 列包含了 "Using index condition"，这表明索引下推被使用了。

覆盖索引：如果一个索引包含了所有需要查询的字段的值，这就是索引覆盖(不需要进行额外的回表操作就能查出所有信息)。
使用explain语句之后如果 Extra 列包含了 "Using index"，这表明查询仅通过索引来获取所需的数据，实现了索引覆盖。

InnoDB的索引是B+树索引
InnoDB的索引分为两种：

- 聚簇索引：以主键的大小作为页和记录的排序规则，在叶子节点处存储的记录包含了表中所有的列
- 二级索引：以索引的大小作为页和记录的排序规则，在叶子节点出存储的记录内容是索引列+主键
  - 联合索引：联合索引是二级索引的一种，以多个列的大小作为页和记录的排序规则，在叶子节点存储的记录内容是索引列+主键

InnoDB存储引擎的B+树根节点字创建之日就不再移动
在二级索引的B+树内节点中，目录项记录由索引列的值、主键值和页号组成
一个数据页至少可以容纳2条记录
MyISAM存储引擎的数据和索引分开存储，这种存储引擎的索引全部都是二级索引，在叶子节点处存储的是列 + 行号

## MySQL的数据目录

## InnoDB的表空间

### 区与段

表空间被划分为许多连续的区，对于大小为16kb的页面来说，每个区默认由64个页（1MB）组成，每256个区（也就是256MB）划分为一组，每个组最开始的几个页面类型是固定的

段是一个逻辑上的概念，是某些零散的页面以及一些完整的区的集合

## 单表访问方法

查询语句在本质上是一种声明式的语法，具体执行方法有很多  
MySQL根据不同的场景划分了很多种访问方法：  

- const
- ref
- ref_or_null
- range
- index
- all
- index_merge

有的查询可以使用索引合并的方式利用多个索引完成查询，具体方法有一下三种：

- Intersection索引合并
- Union索引合并
- Sort-Union索引合并

## 连接的原理

从本质上来说，连接就是把各个表中的记录都取出来依次进行匹配，并把匹配后的组合发送给客户端。如果不加任何过滤条件，产生的结果集就是笛卡尔积

在MySQL中，连接分为内连接和外连接，其中外连接又可以被细分为左（外）连接和右（外）连接。内连接和外连接的根本区别就是，在驱动表中的记录不符合ON子句中的连接条件时，内连接不会把该记录加入到最后的结果集中，而外连接会

## 基于成本的优化

在MySQL中，一个查询的执行成本是由I/O成本和CPU成本组成的。对于InnoDB存储引擎来说，读取一个页面的I/O成本默认是1.0，读取以及检验一条记录是否副和搜索条件的成本默认是0.2

在单表查询中，优化器生成执行计划的步骤一般如下：

1. 根据搜索条件，找出所有可能使用的索引
2. 计算全表扫描的代价
3. 计算使用不同索引执行查询的代价
4. 对比各种执行方案的代价，找出成本最低的那个方案

## InnoDB统计数据是如何收集的

InnoDB以表为单位来手机统计数据。这些统计数据可以是基于磁盘的永久性统计数据，也可以是基于内存的非永久性统计数据

## 基于规则的优化

MySQL会对用户编写的查询语句执行一些重写操作，比如：

- 移除不必要的括号
- 常量传递
- 移除没用的条件
- 表达式计算
- HAVING子句和WHERE子句的合并
- 常量表检测

## EXPLAIN详解

通过EXPLAIN语句可以查看某个语句的执行计划

在EXPLAIN单词和真正的查询语句中间加上FORMAT=JSON，可以得到JSON格式的执行计划

在使用EXPLAIN语句查看了某个查询语句的执行计划之后，紧接着还可以使用SHOW WARNINGS语句查看与这个查询的执行计划有关的扩展信息

## InnoDB的Buffer Pool

Buffer Pool本质上是InnoDB向操作系统申请的一段连续的内存空间，可以通过innodb_buffer_pool_size来调整它的大小

## 事务简介

在 MySQL 中，事务（Transaction）是一个不可分割的工作单位。在同一事务中的一系列数据库操作，要么全部执行成功，要么全部执行失败。事务是用来保证数据一致性的重要机制。

事务具有以下四个基本特性（ACID 特性）：

1. 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。

2. 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏。这是指写入的数据必须满足所有的预定义规则，例如数据类型、长度或者是用户自定义的规则。

3. 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交、读提交、可重复读、串行化。

4. 持久性（Durability）：一旦事务完成，则其结果就能够永久的保存在数据库中。即使系统发生崩溃，重新启动后，数据库还能恢复到事务成功结束的状态。

## redo日志

redo日志记录了事务执行过程中都修改了哪些内容
事务提交时只将执行过程中产生的redo日志刷新到磁盘，而不是将所有修改过的页面都刷新到磁盘，这样做有下面两个好处：

- redo日志占用的空间非常小
- redo日志是顺序写入磁盘的

一条redo日志一般由下面及部分组成：

- type:这条redo日志的类型
- spaceID:表空间ID
- page number:页号
- data:这条redo日志的具体内容

## undo日志

为了保证事务的原子性，InnoDB引入了undo日志。undo日志记载了回滚一个操作所需的必要内容

在事务对表中的记录进行改动时，才会为这个事务分配一个唯一的事务id。事务id值是一个递增的数字。先被分配id的事务得到的是较小的事务id，后背分配id的事务得到的是较大的事务id。未被分配事务id的事务id默认是0。聚簇索引记录中有一个trx_id隐藏列，它代表对这个聚簇索引记录进行改动的语句所在的事务对应的事务id

## 事务隔离级别和MVCC

### 事务隔离级别

并发的事务在运行过程中会出现一些可能引发一致性问题的现象：

- 脏读（Dirty Read）：在同一事务中，一个事务读取到了另一个事务中未提交的数据，另一个事务如果回滚或进行更改会导致数据读取错误

- 不可重复读（Non-Repeatable Read）：在同一事务中，一个查询在不同时间点多次读取同一行或多行数据，却得到了不同的结果。这是因为在两次读取之间，另一个事务修改了这行数据并提交。

- 幻读（Phantom Read）：在同一事务中，一个查询在不同时间点多次执行，第一次和后续的查询返回的行数不同，或者后续查询能读取到第一次查询中不存在的行。这是因为在两次查询之间，另一个事务插入或删除了一些行并提交。

SQL标准中的四种隔离级别如下：

- **READ UNCOMMITTED**:读未提交，一个事务可以看到其他未提交事务的修改。这是最低的事务隔离级别，也是最少用的，因为它可能会导致很多并发问题。
- **READ COMMITTTED**:读已提交，这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的基本要求，一个事务只能看到已经提交的事务所做的修改。这个级别防止了脏读，但是可能会出现不可重复读和幻读。
- **REPEATABLE READ**:可重复读，这是MySQL的默认事务隔离级别。它确保了同一事务的其他实例在该实例完成后不能插入新的行，因此避免了幻读。但是它可能会导致不可重复读。
- **SERIALIZABLE**:这是最高的事务隔离级别，它要求事务序列化执行，事务只能一个接一个地执行，不能并发执行。虽然这个级别可以防止脏读、不可重复读以及幻读，但是这会严重影响性能，因为事务没有并发执行的可能，只能排队等待。

|   | 脏读 | 不可重复读 | 幻读 |
| :------: | :------: | :------: | :------: |
|   READ UNCOMMITTED   |   存在   |   存在   |   存在   |
|   READ COMMITTTED   |   x   |   存在   |   存在   |
|   REPEATABLE READ   |   x   |   x   |   存在   |
|   SERIALIZABLE   |   x   |   x   |   x   |

> MySQL 的默认隔离级别是：可重复读（REPEATABLE READ）  
> MySQL在REPEATABLE READ隔离级别下是可以在很大程度上禁止出现幻读的

查看隔离级别:

```sql
SHOW VARIABLES LIKE 'transaction_isolation';
```

设置隔离级别:

```sql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

### MVCC

MVCC，全称是多版本并发控制（Multi-Version Concurrency Control），是一种用于控制数据库并发访问的技术。

在MySQL中，InnoDB存储引擎使用MVCC来实现事务的隔离级别，并解决读-写和写-写之间的冲突。通过MVCC，不同的事务可以看到数据的不同版本，这样就可以在不锁定整个表的情况下进行并发控制，提高了数据库的并发处理能力。

聚簇索引记录和undo日志中的roll_pointer属性可以串成一个记录的版本连。
通过生成ReadView来判断记录的某个版本的可见性，其中READ COMMITTTED在每一次进行普通SELECT操作前都会生成一个ReadView，之后的查询操作都会重复使用这个ReadView。
当前系统中，如果最早生成的ReadView不在访问undo日志以及打了删除标记的记录，则可以通过purge操作将它们清楚。

## 锁

MVCC和加锁是解决并发事务带来的一致性问题的两种方式。

共享锁简称为S锁，排他锁简称为X锁。
S锁是共享锁的简称，表示多个事务可以共享这个锁，即并发读取是允许的。
X锁是排他锁的简称，表示只有一个事务可以持有这个锁，其他事务不能同时持有，用于保护写操作。
S锁与S锁兼容；X锁与S锁不兼容，与X锁也不兼容。

InnoDB触发锁定读（当前读）的语句：  
UPDATE table_name SET column1 = value1 WHERE condition;  
DELETE FROM table_name WHERE condition;  
INSERT INTO table1 (column1, column2) SELECT column1, column2 FROM table2 WHERE condition;  
SELECT ... LOCK IN SHARE MODE   语句为读取的记录加S锁  
SELECT ... FOR UPDATE           语句为读取的记录加X锁  

!> MySQL默认隔离级别下，大部分情况下不会出现幻读，但是锁定读（当前读）有可能出现幻读

为了解决当前读出现的幻读，MySQL引入了锁机制
MySQL通过Next-Key Lock来解决当前读可能导致的幻读问题

InnoDB中的行级锁有下面这些：

- Record Lock:被我们戏称为正经记录所，只对记录本身枷锁  
- Gap Lock:锁住记录前的间隙，防止别的事务像该间隙插入新记录  
- Next-Key Lock:Record Lock和Gap lock的结合体，既保护记录本身，也防止别的事务像该间隙插入新记录
- Insert Intention Lock:插入意向锁，某个事务获取一条记录的该类型锁后，不会阻止别的事务继续获取该记录上任何烈性的锁  
- 隐式锁:依靠记录的trx_id属性来保护不被别的事务改动该记录  

不同事务由于互相持有对方需要的锁而导致事务都无法继续执行的情况成为死锁。死锁发生时，InnoDB会选择一个较小的事务进行回滚。可以查看死锁日志来分析死锁发生的过程。

<style>
.center
{
  width: auto;
  display: table;
  margin-left: auto;
  margin-right: auto;
}
</style>
